

//------------------------------------------------------------------------------
//  Purpose: 指令函数集 - 总线通讯类（CANBUS）
//  Funtion: 完成所有物理层总线参数设置函数，主要集中与 指令ID 6100 - 6200
//  Dependent:
//  Designer:
//  Date.Ver:
//------------------------------------------------------------------------------
#ifndef FUN_CAN_H
#define FUN_CAN_H

//------------------------------------------------------------------------------
// Funtion: 设置 CAN 标准帧流控制帧
// Input  : argc - 参数长度
//          argv - 参数
// Output : ans - 回复到上位机的数据
// Return : 回复到上位机的数据长度
// Info   : 6018
//------------------------------------------------------------------------------
int SetEnterFrameData_1(int argc, unsigned char * argv, unsigned char * ans);

//------------------------------------------------------------------------------
// Funtion: 设置 CAN 扩展帧流控制帧
// Input  : argc - 参数长度
//          argv - 参数
// Output : ans - 回复到上位机的数据
// Return : 回复到上位机的数据长度
// Info   : 6018
//------------------------------------------------------------------------------
int SetEnterFrameDataExt_1(int argc, unsigned char * argv, unsigned char * ans);

//------------------------------------------------------------------------------
// Funtion: Can发多帧收多帧，收帧数未知
// Input  : argc - 参数长度
//          argv - 参数
// Output : ans - 回复到上位机的数据
// Return : 回复到上位机的数据长度
// Info   : 6203
//------------------------------------------------------------------------------
int CANSendAndReceiveUnknownFrame_1(int argc, unsigned char * argv,
    unsigned char * ans);

//------------------------------------------------------------------------------
// Funtion: 欧宝专用can发多收多
// Input  : argc - 参数长度
//          argv - 参数
// Output : ans - 回复到上位机的数据
// Return : 回复到上位机的数据长度
// Info   : 6207
//------------------------------------------------------------------------------
int GMOPEL_CanSendMulFrameGetMulFrame_1(int argc, unsigned char * argv,
    unsigned char * ans);

//------------------------------------------------------------------------------
// Funtion: Can发多帧收多帧，收帧数未知
// Input  : argc - 参数长度
//          argv - 参数
// Output : ans - 回复到上位机的数据
// Return : 回复到上位机的数据长度
// Info   : 6203
//------------------------------------------------------------------------------
int CANSendAndReceiveUnknownFrame(int argc, unsigned char * argv,
    unsigned char * ans);

//------------------------------------------------------------------------------
// Funtion: 欧宝专用can发多收多
// Input  : argc - 参数长度
//          argv - 参数
// Output : ans - 回复到上位机的数据
// Return : 回复到上位机的数据长度
// Info   : 6207
//------------------------------------------------------------------------------
int GMOPEL_CanSendMulFrameGetMulFrame(int argc, unsigned char * argv,
    unsigned char * ans);

//------------------------------------------------------------------------------
// Funtion: 欧宝专用can发多收多
// Input  : argc - 参数长度
//          argv - (0x61 + 0x1f ) + 发送次数 + 帧数 + 接受帧数 + 第一帧内容（
//                 长度（不包括校验字节） + 内容）
// Output : ans - 回复到上位机的数据
// Return : 回复到上位机的数据长度
// Info   : 611f
// 在使用这个函数的时候要注意的是：
// 1.在这里长度的字节要注意一下.
// 2.不支持扩展帧.
// 3.2012-12-19修改了返回的长度，并对数据发送缓冲区的内容进行了修改使之能够和GX3
// 下位机一样。参数，输入输出测试OK.返回值测试OK;
//------------------------------------------------------------------------------
int HoldenCan20SendOneFrameReceiveDatas_1(int argc, unsigned char * argv,
    unsigned char * ans);

//------------------------------------------------------------------------------
// Funtion: Can发多帧收多帧，收帧数未知
// Input  : argc - 参数长度
//          argv - 参数
//          发送缓冲区的数据格式 : 发送帧数 + 接受帧数(0xff由下位机进行发送) +
//          ID个数 + 长度 + 0x61 + 0x01 ....
//
// Output : ans - 回复到上位机的数据 0x01,0x55,0xaa,
// Return : 0x01
// Info   : 6203
//1. 实例   :
//        发送缓冲区: 0x02 0xff 0x02 0x0d 0x61 0x01 0x08 0xid1 0xid2 0x01,0x01,
//                    0x00,0x00,0x00,0x00
//        接受缓冲区:
//        LPC2368接受缓冲区的内容:
//        0x00,帧数,0x55,0xaa,0x0b,data,data....注意数据中不包含0x21,0x22.
//        函数实现的策略和LPC2368的不一样。功能是一样的。
//        这里要注意的是:流控制命令不包含在发送里面
//2. 函数实现的功能：canbus发送多帧并接受多帧
//3. 时间参数的确认要在另外的函数中进行设置
//4. 函数本身是无法确认接收的帧数的。
//   原因是：在进行多帧接受的时候可能会出现0x10 + len ，，，，的情况.
//5. 流控命令由流控命令函数进行设定。
//6. 2012-12-19修改返回长度字节————测试通过。
//7. 修改了参数的长度,
//------------------------------------------------------------------------------
int CANSendAndReceiveUnknownFrame_1(int argc, unsigned char * argv,
    unsigned char * ans);

//------------------------------------------------------------------------------
// Funtion: 欧宝专用can发多收多
// Input  : argc - 参数长度
//          argv -  发送帧数 + 接受帧数 + 过滤ID的个数 + 第一帧长度 + 第一帧内容
//                  0x03 0x02 0x02 0x0d 0x61 0x01 0x08 id1 id2 0x10 0x08 0x01 0x02
//                  0x03 0x04 0x05 0x06 0x0d 0x61 0x03 0x08 id1 id2 0x21 0x07 0x08
//                  0x09 0x0a 0x0b 0x0c 0x0d 0x0d 0x61 0x01 0x08 id1 id2 0x22 0x0d
//                  0x0e 0x0f 0x00 0x00 0x00 0x00
// Output : ans - 回复到上位机的数据。
//          0x00,帧数,0x55,0xaa,0x0b,data,data....注意数据中不包含0x21,0x22.
//          00 03 0B 08 FD 20 FE 87 5F C0 97 6F 90 97 0B 08 FD 20 FD 73 68 3B 3D
//          97 2C 00 0B 08 FD 20 FC C4 A8
// Return : 回复到上位机的数据长度
// Info   : 6207
// 注意的问题:在接受多帧的时候没有发送流控制命令
// 1.2012-12-19修改返回的数据包含的是数据长度。
//------------------------------------------------------------------------------
int GMOPEL_CanSendMulFrameGetMulFrame_1(int argc, unsigned char * argv,
    unsigned char * ans);

//------------------------------------------------------------------------------
// Funtion:
// Input  : argc - 参数长度
//          argv - 数据格式
//          0x62 + 0x05 + 长度 + 内容 + ID高位 + ID 低位
// Output : ans - 回复到上位机的数据。
// Return : 回复到上位机的数据长度
// Info   : 6205
// 注意的问题:在接受多帧的时候没有发送流控制命令。
//Req:05 EA 20 10 00 02 1A 9B
//Ans:01 60 00 B1
//Ans:08 60 00 20 00 30 5a 9b 34 46 30
//Ans:08 60 00 21 39 31 30 35 35 32 53
//Ans:08 60 00 22 20 20 30 30 31 30 10
//Ans:08 60 00 23 00 00 00 02 32 15 ec
//Ans:08 60 00 24 10 d6 32 2e 34 6c 20
//Ans:08 60 00 25 56 36 20 4d 50 49 20
//Ans:08 60 00 26 20 20 20 20 20 20 20
//Ans:02 60 00 17 20
//Req:01 EA 20 B8
//目前实现的功能是:
//1.在接受到0x10的时候发送确认帧.并且不保存接受数据
//2.2012-12-19进行了返回接受数据的修改.
//上位机接受缓冲区的数据格式是:
//10,55,aa,0c,61,01,07,e8,00,10,00,04,31,b8,00,00,1e(校验位),e8,00,60,
//------------------------------------------------------------------------------
int VWCANSendDataToEcuGetMultiFrameAnswer1_1(int argc, unsigned char * argv,
    unsigned char * ans);

//------------------------------------------------------------------------------
// Funtion:
// Input  : argc - 参数长度
//          argv - 数据格式
//         (0x62 + 0x01 )  + 0x55 + 0xaa +0x0d + 0x61 +0x01 + 0x08 +.........
//         0x55 + 0xaa +0x0d.......
// 发送缓冲区实例
//         : 55 aa 0d 61 01 08 FC 00 02 21 00 00 00 00 00 00 xx
//           (长度里面不包含校验的长度)
//           55 aa 0d 61 01 08 FC 00 30 00 00 00 00 00 00 00 xx
// Output : ans - 回复到上位机的数据。
//        : 数据格式是->02 0f 55 AA 0B 08 FD 00 02 7B 01 00 00 00 00 00 xx
//                         0f 55 AA 0B 08 FD 00 02 7B 01 00 00 00 00 00 xx
// Return : 0xff(接受成功)
//          0x02(接受失败)
// Info   : 6201
// 注意事项:
// 在这里使用方法是:发一帧收多帧,在函数中包涵流控制命令。在部分老下位机中函数中不包含
// 流控制命令.例如6203.
// 不支持扩展帧。
//------------------------------------------------------------------------------
int Can20SendTwoFrameQuickGetInfo_1(int argc, unsigned char * argv,
    unsigned char * ans);

//------------------------------------------------------------------------------
// Funtion:
// Input  : argc - 参数长度
//          argv - 数据格式
//          (0x62 0x13) 总长度, 0x55, 0xaa, 长度 0x61 0x01 data........
//        : 注意这里的总长度是什么意思？
// 实例   : 0x0f 0x55 0xaa 0x0d 0x61 0x01 0x08 0xfc 0x00 0x02 0x62 0x013 0x00
//          0x00 0x00 0xcs
// Output : ans 的数据格式是：
//        : 0x00,0x00,0x帧数,0x55,0xaa,0x0d,0x08,0xfc,0x00,0x02,....
//        : 实例:0x00,0x00,0x02,0x55,0xaa,0x0d,0x08,0xfc,0x00,0x10,0x08,0x01,0x02,
//               0x03,0x04,0x05,0x06,0x07,0x08
// Return : 0xff
// Info   : 6213
// 函数没有进行测试。
//　实现的是丰田a2canbus的发一帧收多帧。
//  在这里主要的问题是:进行接收多帧的时候，如果下位机的数据起始位是小于0X20应该怎么处理.
//  在这里只支持标准帧。
//  没有进行老下位机和新下位机的测试。
//------------------------------------------------------------------------------
int ToyotaA2ModeCanMultiframe_1(int argc, unsigned char * argv,
    unsigned char * ans);

//------------------------------------------------------------------------------
// Funtion:
// Input  : argc - 参数长度
//          argv - 数据格式
//         (0x62 + 0x02 ) 帧数 + 从ECU接受的帧数(当用0XFF表示的时候，就说明是下位机自动判断)
//         + ID的个数支持扩展帧 + 长度 + 61 + 01 + 帧内容。
// 实例   : 01 02 55 aa 0D 61 01 08 FC 00 02 10 81 00 00 00 00 00 (发一帧的数据格式)
//        : 03 02 55 aa 0D 61 01 08 FC 00 10 12 3B 00 4C 46 50 48 0D 61 03 08 FC
//          00 21 35 41 42 43 31 33 39 0D 61 01 08 FC 00 22 FF E3 D6 FF 30 00 00
//          (多帧数据的存放格式)
// Output : ans - 回复到上位机的数据。
//        : 数据格式是->00 01 55 AA 0B 08 FD 00 02 7B 00 00 00 00 00 00(一帧数据格式)
//                    ->00 13 55 AA 0B 08 FD 00 10 82 61 00 4C 46 50 48 34
//                      41 42 43 35 36 39 30 31 38 34 32 33 FF FF FF FF 2A FF FF
//                      FF FF 03 35 FF FF FF FF FF 41 FF
//                      FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
//                      FF FF FF FF FF FF FF FF FF FF
//                      FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
//                      FF FF FF FF FF FF FF FF FF FF
//                      FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
//                      FF FF FF FF FF FF FF FF FF FF FF FF E4 81 FF 30
// Return : 0xff
// Info   : 6202
// 注意事项:
// 1.接受的帧数默认设置为0xff，
// 2.发送完一帧到接受下一帧的时间是设置的是默认的是500(这个地方可能有问题)，
// 3.实现的机制是:首先发送多帧，
// 4.对于收到的多帧中，计数0x20小于0x20时没有进行处理。
// 5.这是一个比较普通的发一帧收多帧,发一帧收多帧,发多帧收多帧.
// 6.发的帧不包括流控制命令。
// 7.下位机不需要设置流控制指令。
//------------------------------------------------------------------------------
int CANSendAndReceiveMultiFrame_1(int argc, unsigned char * argv,
    unsigned char * ans);

//------------------------------------------------------------------------------
// Funtion:
// Input  : argc - 参数长度
//          argv - 数据格式
//         (0x62 + 0x01 )  + 0x55 + 0xaa +0x0d + 0x61 +0x01 + 0x08 +.........
//         0x55 + 0xaa +0x0d.......
// 发送缓冲区实例
//         : 55 aa 0d 61 01 08 FC 00 02 21 00 00 00 00 00 00 xx
//           (长度里面不包含校验的长度)
//           55 aa 0d 61 01 08 FC 00 30 00 00 00 00 00 00 00 xx
// Output : ans - 回复到上位机的数据。
//        : 数据格式是->02 0f 55 AA 0B 08 FD 00 02 7B 01 00 00 00 00 00 xx
//                         0f 55 AA 0B 08 FD 00 02 7B 01 00 00 00 00 00 xx
// Return : 0xff(接受成功)
//          0x02(接受失败)
// Info   : 6201
// 注意事项:
// 在这里使用方法是:发一帧收多帧,在函数中包涵流控制命令。在部分老下位机中函数中
// 不包含流控制命令.例如6203.
// 不支持扩展帧。
//------------------------------------------------------------------------------
int Can20SendTwoFrameQuickGetInfo_1(int argc, unsigned char * argv,
    unsigned char * ans);

//------------------------------------------------------------------------------
// Funtion : CAN_RecieveMultiFrame_Porsche
// Input  : argc - 参数长度
//             argv - 数据格式
//             (0x62 0x18) + 发送帧数 +
//          过滤ID1 + 过滤id2 + 总长度 + 0x55 0xaa  长度  0x61 0x01 data...cs.
//          总长度 + 0x55 0xaa 长度   0x61 0x01 长度 + id1 + id2 + 0XXX........
//        : 注意这里的总长度是什么意思？
// 实例   : 0x0f 0x55 0xaa 0x0d 0x61 0x01 0x08 0xfc 0x00 0x02 0x62 0x013 0x00
//          0x00 0x00 0xcs
// Output : ans 的数据格式是：
//        : 0x00,0x00,0x帧数,KWP的数据组成部分
//        : 0x00,0x01,0x83,0xF1,0x58,021,0x01,0x02,0x00;
// Return : 0xff
// Info   : 6218
// 注意的问题:在老下位机里面，canbus有校验位
//------------------------------------------------------------------------------
int CAN_RecieveMultiFrame_Porsche_1(int argc, unsigned char * argv,
    unsigned char * ans);

//------------------------------------------------------------------------------
// Funtion : CanSendMulFrameGetMoreSingleFrame
// Input   : argc - 参数长度
//           argv - 数据格式
//           发送缓冲区(argv)的数据格式->0x62|0x25|发送的帧数|接受的数据长度|
//           发送的ID个数|发送长度(不包括校验位)|0x61|0x01|canbus数据。
//           发送缓冲区的数据举例:
//           0x单帧的个数 0x02 0xff 0x02 0x0d 0x61 0x01 0x08 0xfd 0x00 0x10 0x08
//                        0x21 0x01 0x02 0x03 0x04 0x05 0x0d 0x61 0x01 0x08 0xfd
//                        0x00 0x06 0x07 0x00 0x00 0x00 0x00 0x00 0x00.
// Output  : ans
//         :接受缓冲区的数据格式:0x00|帧数|0x55|0xaa|0x0d|canbus数据
//         :数据格式举例: 0x00 0x03 0x55 0xAA 0x0B 0x08 0xFD 0x00 0x10
//                        0x14 0x61 0xE0 0x00 0x05 0x19 0x03
//                        0x02 0x44 0xFF 0xFF 0x02 0x49 0x02
//                        0x66 0xFF 0xFF 0xFF 0xFF 0x00 0x00 0xF1
// Return : 0xff
// Info   : 6227
// 注意的问题:在老下位机里面.
// 注意在这里所有的接受的数据的长度都是下位机自己判断的.
// 这里与6203不同的时在进行
// 这里主要处理的是连续的多帧.
// 能够接收独立的多帧
// 1.2012-12-19添加了返回数据的长度的功能.
//------------------------------------------------------------------------------
int CanSendMulFrameGetMoreSingleFrame_1(int argc, unsigned char * argv,
    unsigned char * ans);

//------------------------------------------------------------------------------
// Funtion : CANSendAndReceiveUnknownFrame_benz
// Input   : argc - 参数长度
//           argv - 数据格式
//           发送缓冲区(argv)的数据格式->0x62|0x25|发送的帧数|接受的数据长度|
//           发送的ID个数|发送长度(不包括校验位)|0x61|0x01|canbus数据。
//           发送缓冲区的数据举例:
//           0x02 0xff 0x02 0x0d 0x61 0x01 0x08 0xfd 0x00 0x10 0x08 0x21 0x01
//           0x02 0x03 0x04 0x05
//           0x0d 0x61 0x01 0x08 0xfd 0x00 0x06 0x07 0x00 0x00 0x00 0x00 0x00 0x00.
// Output  : ans
//         :接受缓冲区的数据格式:0x00|帧数|0x55|0xaa|0x0d|canbus数据
//         :数据格式举例: 0x00 0x03 0x55 0xAA 0x0B 0x08 0xFD 0x00 0x10
//                        0x14 0x61 0xE0 0x00 0x05 0x19 0x03 0x02 0x44
//          0xFF 0xFF 0x02 0x49 0x02 0x66 0xFF 0xFF 0xFF 0xFF 0x00 0x00 0xF1
// Return : 0xff
// Info   : 6225
// 注意的问题:在老下位机里面.
// 注意在这里所有的接受的数据的长度都是下位机自己判断的.
// 这里与6203不同的时在进行
//------------------------------------------------------------------------------
int CANSendAndReceiveUnknownFrame_benz_1(int argc, unsigned char * argv,
    unsigned char * ans);

//------------------------------------------------------------------------------
// Funtion: 无效果
// Input  : argc - 参数长度
//          argv - 参数
// Output : ans - 回复到上位机的数据
// Return : 回复到上位机的数据长度
// Info   : 6114 send: ff,00, 表示成功
//------------------------------------------------------------------------------
int CanbusSendTwoFrameToEcuGetAnswerOldCon10_1(int argc, unsigned char * argv,
    unsigned char * ans);

//------------------------------------------------------------------------------
// Funtion: Can发多帧收多帧，收帧数未知
// Input  : argc - 参数长度
//          argv - 参数
//          发送缓冲区的数据格式 : 发送帧数 + 接受帧数(0xff由下位机进行发送) +
//          ID个数 + 长度 + 0x61 + 0x01 ....
//
// Output : ans - 回复到上位机的数据 0x01,0x55,0xaa,
// Return : 0x01
// Info   : 6208
//1. 实例   :
//        发送缓冲区: 0x02 0xff 0x02 0x0d 0x61 0x01 0x08 0xid1 0xid2 0x01,0x01,
//                    0x00,0x00,0x00,0x00
//        接受缓冲区:
//        LPC2368接受缓冲区的内容:
//        0x00,帧数,0x55,0xaa,0x0b,data,data....注意数据中不包含0x21,0x22.
//发多帧收多帧(指定帧或者自动识别)，发第一帧的时候，ECU可能没有准备好，这个时候不一定会回30
//发完之后，接收一帧，此时可能出现7f 78，需要反复接收
//发多帧的打包，第一帧和最后一帧要6101，中间用6103
//接收帧数为ff的话，直到接收超时才返回;不为ff的话，则返回指定的接收帧数，即使接收不够，将实际接收的帧数返回
//固定2个ID或者4个ID
//ziyingzhu 修改并在平台上测试成功 2009-9-16 9:44
//里面对CAN帧操作的函数，其他模块可以借鉴
//返回数据格式帧数+每帧数据
//发送多帧的时候，按照15765的流控.接收帧只进行7f 78的判断(接收多帧假设不需要发送流控的30帧)
//能否完成发单帧，收多帧，进行7f 78的判断
//------------------------------------------------------------------------------
int DongFengSendMultiFrameAndReceiveOneFrame_1(int argc, unsigned char * argv,
    unsigned char * ans);

//------------------------------------------------------------------------------
// Funtion: GM发多帧
// Input  : argc - 参数长度
//          argv - 参数
// Output : ans - 回复到上位机的数据
// Return : 回复到上位机的数据长度
// Info   : 620D
//          00,03,fc,00,08,10,0e,2c,fe,00,04,00,0d,08,21,00,0f,11,52,12,b1,13,08,
//          22,1f,00,00,00,00,00,00,bd,
//------------------------------------------------------------------------------
int GMSendMultiFrameToECUGetAnswer_1(int argc, unsigned char * argv,
    unsigned char * ans);

#endif

//--------------------------------------------------------- End Of File --------
